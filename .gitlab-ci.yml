stages:
  - Prepare
  - Build
# Commenting out the scanning stage for now since the Bitnami images trigger a lot of results.
# We'll add this back in when we have time to sift through all of them.
#  - test
  - Networking
  - Bootstrap
  - Deploy
  - Cleanup
  - Tag
  - Release

variables:
  DEPLOY_HOST_A: catalog-a.aws.lib.msu.edu
  DEPLOY_HOST_B: catalog-b.aws.lib.msu.edu
  DEPLOY_HOST_C: catalog-c.aws.lib.msu.edu
  COMPOSE_PATH: /home/deploy/$CI_COMMIT_BRANCH

Set Stack Name:
  stage: Prepare
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_PIPELINE_SOURCE == "schedule"'
  script:
    - |
      STACK_NAME=
      if [[ $CI_DEFAULT_BRANCH == $CI_COMMIT_BRANCH ]]; then
          STACK_NAME="catalog-beta"
      elif [[ "${CI_COMMIT_BRANCH}" == "devel-"* || "${CI_COMMIT_BRANCH}" == "review-"* ]]; then
          STACK_NAME="${CI_COMMIT_BRANCH}"
      fi
      echo "STACK_NAME=${STACK_NAME}" > build.env
  artifacts:
    reports:
      dotenv: build.env

Create DNS:
  stage: Prepare
  extends: .stack_template
  image: $CI_REGISTRY_IMAGE/ansible:latest
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/'
  needs:
    - job: Set Stack Name
      artifacts: true
  script:
    # Add .aws credentials
    - cat provision-dns-playbook/variables.yml | envsubst | sponge provision-dns-playbook/variables.yml
    # Replace STACK_NAME in env/prod/main.tf and create host file in provision-dns-playbook
    - cat dns-terraform/env/prod/main.tf | envsubst | sponge dns-terraform/env/prod/main.tf
    # Run playbook
    - ansible-playbook provision-dns-playbook/provision.yml
    # Give time for DNS to propogate
    - sleep 60

Deploy Compose Files:
  stage: Prepare
  extends: .stack_template
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_PIPELINE_SOURCE == "schedule"'
  needs:
    - job: Set Stack Name
      artifacts: true
  script:
    # Install yq, enbsubst, and sponge
    - apk add wget gettext moreutils
    - wget https://github.com/mikefarah/yq/releases/download/v4.26.1/yq_linux_amd64 -O ./yq
    - chmod +x ./yq
    # Add basicauth password for restricted resources
    - ./yq -i ".services.traefik.deploy.labels[2]=\"traefik.http.middlewares.restrict-auth.basicauth.users=$BASICAUTH_FOR_RESOURCES\"" docker-compose.traefik.yml
    # Modify the image tag from :latest -> $CI_COMMIT_SHORT_SHA
    - ./yq -i ".services.catalog.image=\"$CI_REGISTRY_IMAGE/vufind:$CI_COMMIT_SHORT_SHA\"" docker-compose.yml
    - ./yq -i ".services.harvest.image=\"$CI_REGISTRY_IMAGE/vufind:$CI_COMMIT_SHORT_SHA\"" docker-compose.yml
    - ./yq -i ".services.galera.image=\"$CI_REGISTRY_IMAGE/db:$CI_COMMIT_SHORT_SHA\"" docker-compose.mariadb-cloud-bootstrap.yml
    - ./yq -i ".services.galera.image=\"$CI_REGISTRY_IMAGE/db:$CI_COMMIT_SHORT_SHA\"" docker-compose.mariadb-cloud.yml
    - ./yq -i ".services.galera.image=\"$CI_REGISTRY_IMAGE/db:$CI_COMMIT_SHORT_SHA\"" docker-compose.mariadb-cloud-force.yml
    - ./yq -i ".services.solr.image=\"$CI_REGISTRY_IMAGE/solr:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud-bootstrap.yml
    - ./yq -i ".services.zk1.image=\"$CI_REGISTRY_IMAGE/zk:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud-bootstrap.yml
    - ./yq -i ".services.zk2.image=\"$CI_REGISTRY_IMAGE/zk:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud-bootstrap.yml
    - ./yq -i ".services.zk3.image=\"$CI_REGISTRY_IMAGE/zk:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud-bootstrap.yml
    - ./yq -i ".services.solr.image=\"$CI_REGISTRY_IMAGE/solr:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud.yml
    - ./yq -i ".services.zk1.image=\"$CI_REGISTRY_IMAGE/zk:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud.yml
    - ./yq -i ".services.zk2.image=\"$CI_REGISTRY_IMAGE/zk:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud.yml
    - ./yq -i ".services.zk3.image=\"$CI_REGISTRY_IMAGE/zk:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud.yml
    # Modify the name of internal network to include $STACK_NAME
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.internal.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.mariadb-cloud-bootstrap.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.mariadb-cloud.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.mariadb-cloud-force.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.solr-cloud-bootstrap.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.solr-cloud.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.yml
    # Add labels for host rule if stack name is catalog-beta
    - if [ "${STACK_NAME}" == "catalog-beta" ]; then ./yq -i ".services.catalog.deploy.labels += \"traefik.http.routers.catalog-beta-http-router.rule=Host(\`catalog-beta.lib.msu.edu\`)\"" docker-compose.yml; fi
    - if [ "${STACK_NAME}" == "catalog-beta" ]; then ./yq -i ".services.catalog.deploy.labels += \"traefik.http.routers.catalog-beta-https-router.rule=Host(\`catalog-beta.lib.msu.edu\`)\"" docker-compose.yml; fi
    # Add $STACK_NAME to solr traefik labels
    - ./yq -i ".x-solr-deploy.labels[1] =\"traefik.http.routers.${STACK_NAME}-msul-solr-router.entrypoints=msul-http-ent\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[2] =\"traefik.http.routers.${STACK_NAME}-msul-solr-router.service=${STACK_NAME}-msul-solr-app\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[3] =\"traefik.http.services.${STACK_NAME}-msul-solr-app.loadbalancer.server.port=8983\"" docker-compose.solr-cloud.yml
    - if [ "${STACK_NAME}" != "catalog-beta" ]; then ./yq -i ".x-solr-deploy.labels[4] =\"traefik.http.routers.${STACK_NAME}-msul-solr-router.rule=Host(\`${STACK_NAME}.aws.lib.msu.edu\`) && PathPrefix(\`/solr\`)\"" docker-compose.solr-cloud.yml; fi
    - if [ "${STACK_NAME}" == "catalog-beta" ]; then ./yq -i ".x-solr-deploy.labels[4] =\"traefik.http.routers.${STACK_NAME}-msul-solr-router.rule=Host(\`${STACK_NAME}.lib.msu.edu\`) && PathPrefix(\`/solr\`)\"" docker-compose.solr-cloud.yml; fi
    - ./yq -i ".x-solr-deploy.labels[5] =\"traefik.http.routers.${STACK_NAME}-msul-solr-router.middlewares=http-redirect\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[6] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.entrypoints=msul-https-ent\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[7] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.service=${STACK_NAME}-https-msul-solr-app\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[8] =\"traefik.http.services.${STACK_NAME}-https-msul-solr-app.loadbalancer.server.port=8983\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[9] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.middlewares=restrict-auth\"" docker-compose.solr-cloud.yml
    - if [ "${STACK_NAME}" != "catalog-beta" ]; then ./yq -i ".x-solr-deploy.labels[10] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.rule=Host(\`${STACK_NAME}.aws.lib.msu.edu\`) && PathPrefix(\`/solr\`)\"" docker-compose.solr-cloud.yml; fi
    - if [ "${STACK_NAME}" == "catalog-beta" ]; then ./yq -i ".x-solr-deploy.labels[10] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.rule=Host(\`${STACK_NAME}.lib.msu.edu\`) && PathPrefix(\`/solr\`)\"" docker-compose.solr-cloud.yml; fi
    - ./yq -i ".x-solr-deploy.labels[11] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.tls=true\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[12] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.tls.certresolver=msul-letsencrypt\"" docker-compose.solr-cloud.yml
    # Remove the harvest service if the stack name is NOT catalog-beta
    - if [ "${STACK_NAME}" != "catalog-beta" ]; then ./yq -i "del(.services.harvest)" docker-compose.yml; fi
    # Replace $STACK_NAME in main compose file
    - cat docker-compose.yml | envsubst | sponge docker-compose.yml
    # Remove blank lines as a workaround for issue caused by: https://github.com/mikefarah/yq/issues/1191
    - sed -i "/^$/d" docker-compose.traefik.yml
    - sed -i "/^$/d" docker-compose.internal.yml
    # Copy the updated compose files to the server
    - ssh deploy@$DEPLOY_HOST_A mkdir -p $COMPOSE_PATH
    - scp docker-compose* deploy@$DEPLOY_HOST_A:$COMPOSE_PATH/

Deploy Internal Network:
  stage: Networking
  extends: .stack_template
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Compose Files
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker stack deploy -c $COMPOSE_PATH/docker-compose.internal.yml $STACK_NAME-internal && sleep 15"

Deploy Traefik:
  stage: Networking
  extends: .stack_template
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Compose Files
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker stack deploy -c $COMPOSE_PATH/docker-compose.traefik.yml traefik && sleep 15"

Bootstrap Stacks:
  stage: Bootstrap
  extends: .stack_template
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Compose Files
    - Deploy Internal Network
    - Build DB Image
    - Build Solr Image
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker login -u cicd -p $REGISTRY_ACCESS_TOKEN $CI_REGISTRY &&
      (docker volume ls | grep -q ${STACK_NAME}-mariadb || (docker stack deploy --with-registry-auth -c $COMPOSE_PATH/docker-compose.mariadb-cloud-bootstrap.yml ${STACK_NAME}-mariadb && sleep 30)) &&
      (docker volume ls | grep -q ${STACK_NAME}-solr || (docker stack deploy --with-registry-auth -c $COMPOSE_PATH/docker-compose.solr-cloud-bootstrap.yml ${STACK_NAME}-solr && sleep 90))"

Deploy Solr:
  stage: Deploy
  extends: .stack_template
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_PIPELINE_SOURCE == "schedule"'
  needs:
    - job: Set Stack Name
      artifacts: true
    - Build Solr Image
    - Build ZK Image
    - Bootstrap Stacks
    - Deploy Compose Files
    - Deploy Internal Network
    - Deploy Traefik
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker login -u cicd -p $REGISTRY_ACCESS_TOKEN $CI_REGISTRY &&
      docker stack deploy --with-registry-auth -c $COMPOSE_PATH/docker-compose.solr-cloud.yml ${STACK_NAME}-solr"

Deploy Swarm Cron:
  stage: Deploy
  extends: .stack_template
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker stack deploy -c $COMPOSE_PATH/docker-compose.swarm-cron.yml swarm-cron"

Deploy DB:
  stage: Deploy
  extends: .stack_template
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_PIPELINE_SOURCE == "schedule"'
  needs:
    - job: Set Stack Name
      artifacts: true
    - Build DB Image
    - Bootstrap Stacks
    - Deploy Compose Files
    - Deploy Internal Network
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker login -u cicd -p $REGISTRY_ACCESS_TOKEN $CI_REGISTRY &&
      docker stack deploy --with-registry-auth -c $COMPOSE_PATH/docker-compose.mariadb-cloud.yml ${STACK_NAME}-mariadb && sleep 45"

Deploy Vufind:
  stage: Deploy
  extends: .stack_template
  environment:
    name: $CI_COMMIT_BRANCH
    url: $URL
    on_stop: Remove Environment
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_PIPELINE_SOURCE == "schedule"'
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Traefik
    - Deploy Internal Network
    - Build Vufind Image
    - Deploy DB
    - Deploy Solr
    - Deploy Compose Files
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker login -u cicd -p $REGISTRY_ACCESS_TOKEN $CI_REGISTRY &&
      docker stack deploy --with-registry-auth -c $COMPOSE_PATH/docker-compose.yml $STACK_NAME-catalog"
    # If this is a non-prod instance, load some records
    - >
      if [ "${STACK_NAME}" != "catalog-beta" ]; then
        IMPORT_ATTEMPTS=0;
        CAT_CONTAINER=;
        sleep 15;
        while [[ "$IMPORT_ATTEMPTS" -le 5 ]]; do
            TARGET_IMAGE=$(ssh deploy@$DEPLOY_HOST_A "docker ps -q -f name=${STACK_NAME}-catalog_catalog --format '{{ .Image }}'");
            if [[ "$TARGET_IMAGE" == "$CI_REGISTRY_IMAGE/vufind:$CI_COMMIT_SHORT_SHA" ]]; then
                CAT_CONTAINER=$(ssh deploy@$DEPLOY_HOST_A "docker ps -q -f name=${STACK_NAME}-catalog_catalog");
                break;
            fi
            echo "Catalog container not online. Waiting...";
            sleep 10;
            IMPORT_ATTEMPTS=$((IMPORT_ATTEMPTS+1));
        done
        echo "Running harvest-and-import.sh now";
        ssh deploy@$DEPLOY_HOST_A "docker exec ${CAT_CONTAINER} /harvest-and-import.sh -c -l 1 -b -v -r >/dev/null 2>&1";
        echo "Import completed with exit code $?";
        URL="https://${STACK_NAME}.aws.lib.msu.edu";
      else
        URL="https://catalog-beta.lib.msu.edu";
      fi
    # Report the environemnt URL to GitLab
    - echo "URL=$URL" >> deploy.env
  artifacts:
    reports:
      dotenv: deploy.env

Remove Environment:
  stage: Cleanup
  extends: .stack_template
  image: $CI_REGISTRY_IMAGE/ansible:latest
  environment:
    name: $CI_COMMIT_BRANCH
    action: stop
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/'
      when: manual
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Vufind
  script:
    # Add .aws credentials
    - cat provision-dns-playbook/variables.yml | envsubst | sponge provision-dns-playbook/variables.yml
    # Replace STACK_NAME in env/prod/main.tf and create host file in provision-dns-playbook
    - cat dns-terraform/env/prod/main.tf | envsubst | sponge dns-terraform/env/prod/main.tf
    # Run playbook
    - ansible-playbook provision-dns-playbook/decommission.yml
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker stack rm $STACK_NAME-solr;
      docker stack rm $STACK_NAME-mariadb;
      docker stack rm $STACK_NAME-catalog;
      docker stack rm $STACK_NAME-internal;
      rm -rf $COMPOSE_PATH;
      sleep 15;
      docker system prune --volumes -a -f"
    - ssh-keyscan $DEPLOY_HOST_B >> ~/.ssh/known_hosts
    - ssh-keyscan $DEPLOY_HOST_C >> ~/.ssh/known_hosts
    - ssh deploy@$DEPLOY_HOST_B "docker system prune --volumes -a -f"
    - ssh deploy@$DEPLOY_HOST_C "docker system prune --volumes -a -f"

############# Templates ###############

.stack_template:
  tags:
    - msul-shared
  extends: .setup_ssh
  variables:
    ENCODED_PRIVATE_KEY: $DEPLOY_PRIVATE_KEY
    SERVER: $DEPLOY_HOST_A
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_PIPELINE_SOURCE == "schedule"'
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Compose Files

include:
  - project: 'msu-libraries/ci-cd/ci-cd'
    ref: main
    file: '/templates/SSH.gitlab-ci.yml'
  - 'templates/Build.gitlab-ci.yml'
#  - 'templates/Scan.gitlab-ci.yml'
  - 'templates/Release.gitlab-ci.yml'
