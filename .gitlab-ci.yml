stages:
  - Prepare
  - Build
  - test
  - Networking
  - Bootstrap
  - Deploy
  - Post-Deploy
  - Cleanup
  - Release

variables:
  VUFIND_VERSION: "8.1"
  # Used during upgrade, which needs to know previous version
  PREV_VUFIND_VERSION: "8.0.4"
  DEPLOY_HOST_A: catalog-1.aws.lib.msu.edu
  DEPLOY_HOST_B: catalog-2.aws.lib.msu.edu
  DEPLOY_HOST_C: catalog-3.aws.lib.msu.edu
  COMPOSE_PATH: /home/deploy/$CI_COMMIT_BRANCH

Set Stack Name:
  stage: Prepare
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_PIPELINE_SOURCE == "schedule"'
  script:
    - |
      STACK_NAME=
      if [[ $CI_DEFAULT_BRANCH == $CI_COMMIT_BRANCH ]]; then
          STACK_NAME="catalog-beta"
      elif [[ "${CI_COMMIT_BRANCH}" == "devel-"* || "${CI_COMMIT_BRANCH}" == "review-"* ]]; then
          STACK_NAME="${CI_COMMIT_BRANCH}"
      fi
      echo "STACK_NAME=${STACK_NAME}" > build.env
  artifacts:
    reports:
      dotenv: build.env

Create DNS:
  stage: Prepare
  extends: .stack_template
  image: $CI_REGISTRY_IMAGE/ansible:latest
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/'
  needs:
    - job: Set Stack Name
      artifacts: true
  script:
    # Add .aws credentials
    - cat provision-dns-playbook/variables.yml | envsubst | sponge provision-dns-playbook/variables.yml
    # Replace STACK_NAME in env/prod/main.tf and create host file in provision-dns-playbook
    - cat dns-terraform/env/prod/main.tf | envsubst | sponge dns-terraform/env/prod/main.tf
    # Run playbook
    - ansible-playbook provision-dns-playbook/provision.yml
    # Give time for DNS to propogate
    - sleep 60

Deploy Compose Files:
  stage: Prepare
  extends: .stack_template
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_PIPELINE_SOURCE == "schedule"'
  needs:
    - job: Set Stack Name
      artifacts: true
  script:
    # Install yq, enbsubst, and sponge
    - apk add wget gettext moreutils
    - "wget --header=\"Authorization: token $GITHUB_USER_TOKEN\" https://github.com/mikefarah/yq/releases/download/v4.26.1/yq_linux_amd64 -O ./yq"
    - chmod +x ./yq
    # Add basicauth password for restricted resources
    - ./yq -i ".services.traefik.deploy.labels[2]=\"traefik.http.middlewares.restrict-auth.basicauth.users=$BASICAUTH_FOR_RESOURCES\"" docker-compose.traefik.yml
    # Modify the image tag from :latest -> $CI_COMMIT_SHORT_SHA
    - ./yq -i ".services.catalog.image=\"$CI_REGISTRY_IMAGE/vufind:$CI_COMMIT_SHORT_SHA\"" docker-compose.yml
    - ./yq -i ".services.cron.image=\"$CI_REGISTRY_IMAGE/vufind:$CI_COMMIT_SHORT_SHA\"" docker-compose.yml
    - ./yq -i ".services.galera.image=\"$CI_REGISTRY_IMAGE/db:$CI_COMMIT_SHORT_SHA\"" docker-compose.mariadb-cloud-bootstrap.yml
    - ./yq -i ".services.galera.image=\"$CI_REGISTRY_IMAGE/db:$CI_COMMIT_SHORT_SHA\"" docker-compose.mariadb-cloud.yml
    - ./yq -i ".services.galera.image=\"$CI_REGISTRY_IMAGE/db:$CI_COMMIT_SHORT_SHA\"" docker-compose.mariadb-cloud-force.yml
    - ./yq -i ".services.solr.image=\"$CI_REGISTRY_IMAGE/solr:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud-bootstrap.yml
    - ./yq -i ".services.zk.image=\"$CI_REGISTRY_IMAGE/zk:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud-bootstrap.yml
    - ./yq -i ".services.solr.image=\"$CI_REGISTRY_IMAGE/solr:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud.yml
    - ./yq -i ".services.cron.image=\"$CI_REGISTRY_IMAGE/solr:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud.yml
    - ./yq -i ".services.zk.image=\"$CI_REGISTRY_IMAGE/zk:$CI_COMMIT_SHORT_SHA\"" docker-compose.solr-cloud.yml
    # Modify the name of internal network to include $STACK_NAME
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.internal.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.mariadb-cloud-bootstrap.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.mariadb-cloud.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.mariadb-cloud-force.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.solr-cloud-bootstrap.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.solr-cloud.yml
    - ./yq -i ".networks.internal.name=\"${STACK_NAME}-internal\"" docker-compose.yml
    # Add labels for host rule if stack name is catalog-beta
    - if [ "${STACK_NAME}" == "catalog-beta" ]; then ./yq -i ".services.catalog.deploy.labels += \"traefik.http.routers.catalog-beta-http-router.rule=Host(\`catalog-beta.lib.msu.edu\`)\"" docker-compose.yml; fi
    - if [ "${STACK_NAME}" == "catalog-beta" ]; then ./yq -i ".services.catalog.deploy.labels += \"traefik.http.routers.catalog-beta-https-router.rule=Host(\`catalog-beta.lib.msu.edu\`)\"" docker-compose.yml; fi
    # Add $STACK_NAME to solr traefik labels
    - ./yq -i ".x-solr-deploy.labels[1] =\"traefik.http.routers.${STACK_NAME}-msul-solr-router.entrypoints=msul-http-ent\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[2] =\"traefik.http.routers.${STACK_NAME}-msul-solr-router.service=${STACK_NAME}-msul-solr-app\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[3] =\"traefik.http.services.${STACK_NAME}-msul-solr-app.loadbalancer.server.port=8983\"" docker-compose.solr-cloud.yml
    - if [ "${STACK_NAME}" != "catalog-beta" ]; then ./yq -i ".x-solr-deploy.labels[4] =\"traefik.http.routers.${STACK_NAME}-msul-solr-router.rule=Host(\`${STACK_NAME}.aws.lib.msu.edu\`) && PathPrefix(\`/solr\`)\"" docker-compose.solr-cloud.yml; fi
    - if [ "${STACK_NAME}" == "catalog-beta" ]; then ./yq -i ".x-solr-deploy.labels[4] =\"traefik.http.routers.${STACK_NAME}-msul-solr-router.rule=Host(\`${STACK_NAME}.lib.msu.edu\`) && PathPrefix(\`/solr\`)\"" docker-compose.solr-cloud.yml; fi
    - ./yq -i ".x-solr-deploy.labels[5] =\"traefik.http.routers.${STACK_NAME}-msul-solr-router.middlewares=http-redirect\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[6] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.entrypoints=msul-https-ent\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[7] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.service=${STACK_NAME}-https-msul-solr-app\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[8] =\"traefik.http.services.${STACK_NAME}-https-msul-solr-app.loadbalancer.server.port=8983\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[9] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.middlewares=restrict-auth\"" docker-compose.solr-cloud.yml
    - if [ "${STACK_NAME}" != "catalog-beta" ]; then ./yq -i ".x-solr-deploy.labels[10] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.rule=Host(\`${STACK_NAME}.aws.lib.msu.edu\`) && PathPrefix(\`/solr\`)\"" docker-compose.solr-cloud.yml; fi
    - if [ "${STACK_NAME}" == "catalog-beta" ]; then ./yq -i ".x-solr-deploy.labels[10] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.rule=Host(\`${STACK_NAME}.lib.msu.edu\`) && PathPrefix(\`/solr\`)\"" docker-compose.solr-cloud.yml; fi
    - ./yq -i ".x-solr-deploy.labels[11] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.tls=true\"" docker-compose.solr-cloud.yml
    - ./yq -i ".x-solr-deploy.labels[12] =\"traefik.http.routers.${STACK_NAME}-https-msul-solr-router.tls.certresolver=msul-letsencrypt\"" docker-compose.solr-cloud.yml
    # Set the stack name in the solr cron environment variable
    - ./yq -i ".services.cron.environment[\"STACK_NAME\"]=\"${STACK_NAME}\"" docker-compose.solr-cloud.yml
    # Remove the cron service if the stack name is NOT catalog-beta
    - if [ "${STACK_NAME}" != "catalog-beta" ]; then ./yq -i "del(.services.cron)" docker-compose.yml; fi
    # Unset parallelism limit for non-production to speed up redeployments on devel stacks
    - if [ "${STACK_NAME}" != "catalog-beta" ]; then ./yq -i "del(.services.catalog.deploy.update_config.parallelism)" docker-compose.yml; fi
    # Replace $STACK_NAME in main compose file
    - cat docker-compose.yml | envsubst | sponge docker-compose.yml
    # Remove blank lines as a workaround for issue caused by: https://github.com/mikefarah/yq/issues/1191
    - sed -i "/^$/d" docker-compose.traefik.yml
    - sed -i "/^$/d" docker-compose.internal.yml
    # Copy the updated compose files to the server
    - ssh deploy@$DEPLOY_HOST_A mkdir -p $COMPOSE_PATH
    - scp docker-compose* deploy@$DEPLOY_HOST_A:$COMPOSE_PATH/

Deploy Internal Network:
  stage: Networking
  extends: .stack_template
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Compose Files
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker stack deploy -c $COMPOSE_PATH/docker-compose.internal.yml $STACK_NAME-internal && sleep 15"

Deploy Traefik:
  stage: Networking
  extends: .stack_template
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Compose Files
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker stack deploy -c $COMPOSE_PATH/docker-compose.traefik.yml traefik && sleep 15"

Bootstrap Stacks:
  stage: Bootstrap
  extends: .stack_template
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Compose Files
    - Deploy Internal Network
    - Build DB Image
    - Build Solr Image
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker login -u cicd -p $REGISTRY_ACCESS_TOKEN $CI_REGISTRY &&
      (docker volume ls | grep -q ${STACK_NAME}-mariadb || (docker stack deploy --with-registry-auth -c $COMPOSE_PATH/docker-compose.mariadb-cloud-bootstrap.yml ${STACK_NAME}-mariadb && sleep 30 && docker stack rm ${STACK_NAME}-mariadb && sleep 25)) &&
      (docker volume ls | grep -q ${STACK_NAME}-solr || (docker stack deploy --with-registry-auth -c $COMPOSE_PATH/docker-compose.solr-cloud-bootstrap.yml ${STACK_NAME}-solr && sleep 90))"

Deploy Solr:
  stage: Deploy
  extends: .stack_template
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_PIPELINE_SOURCE == "schedule"'
  needs:
    - job: Set Stack Name
      artifacts: true
    - Build Solr Image
    - Build ZK Image
    - Bootstrap Stacks
    - Deploy Compose Files
    - Deploy Internal Network
    - Deploy Traefik
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker login -u cicd -p $REGISTRY_ACCESS_TOKEN $CI_REGISTRY &&
      docker stack deploy --with-registry-auth -c $COMPOSE_PATH/docker-compose.solr-cloud.yml ${STACK_NAME}-solr"

Deploy Swarm Cron:
  stage: Deploy
  extends: .stack_template
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker stack deploy -c $COMPOSE_PATH/docker-compose.swarm-cron.yml swarm-cron"

Deploy DB:
  stage: Deploy
  extends: .stack_template
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_PIPELINE_SOURCE == "schedule"'
  needs:
    - job: Set Stack Name
      artifacts: true
    - Build DB Image
    - Bootstrap Stacks
    - Deploy Compose Files
    - Deploy Internal Network
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker login -u cicd -p $REGISTRY_ACCESS_TOKEN $CI_REGISTRY &&
      docker stack deploy --with-registry-auth -c $COMPOSE_PATH/docker-compose.mariadb-cloud.yml ${STACK_NAME}-mariadb && sleep 45"

Deploy Vufind:
  stage: Deploy
  extends: .stack_template
  environment:
    name: $CI_COMMIT_BRANCH
    url: $URL
    on_stop: Remove Environment
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_PIPELINE_SOURCE == "schedule"'
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Traefik
    - Deploy Internal Network
    - Build Vufind Image
    - Deploy DB
    - Deploy Solr
    - Deploy Compose Files
  script:
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker login -u cicd -p $REGISTRY_ACCESS_TOKEN $CI_REGISTRY &&
      docker stack deploy --with-registry-auth -c $COMPOSE_PATH/docker-compose.yml $STACK_NAME-catalog"
    # Determine URL
    - >
      if [ "${STACK_NAME}" != "catalog-beta" ]; then
        URL="https://${STACK_NAME}.aws.lib.msu.edu";
      else
        URL="https://catalog-beta.lib.msu.edu";
      fi
    # Report the environemnt URL to GitLab
    - echo "URL=$URL" >> deploy.env
  artifacts:
    reports:
      dotenv: deploy.env

Vufind Upgrade:
  stage: Post-Deploy
  extends: .stack_template
  needs:
    - job: Set Stack Name
      artifacts: true
    - job: Deploy Vufind
      artifacts: true
  script:
    # TODO -- backup of database before running upgrade (can use what we implement in PC-74)
    - HOSTS="$DEPLOY_HOST_A $DEPLOY_HOST_B $DEPLOY_HOST_C";
    - |
        setconfig() {
            OLDVAL=$1;
            NEWVAL=$2;
            for HOST in ${HOSTS}; do
                CONTAINER=$(ssh deploy@$HOST "docker ps -q -f name=${STACK_NAME}-catalog_catalog");
                ssh deploy@$HOST "docker exec ${CONTAINER} sed -i 's/autoConfigure = $OLDVAL/autoConfigure = $NEWVAL/g' local/config/vufind/config.ini";
            done
        }
        catalogwait() {
            sleep 15;
            for HOST in ${HOSTS}; do
                echo "Checking to see if catalog container for ${HOST} is online ($CI_REGISTRY_IMAGE/vufind:$CI_COMMIT_SHORT_SHA)...";
                ATTEMPTS=0;
                while [[ "$ATTEMPTS" -le 20 ]]; do
                    TARGET_IMAGE=$(ssh deploy@$HOST "docker ps -q -f name=${STACK_NAME}-catalog_catalog --format '{{ .Image }}' 2>/dev/null");
                    if [[ "$TARGET_IMAGE" == "$CI_REGISTRY_IMAGE/vufind:$CI_COMMIT_SHORT_SHA" ]]; then
                        echo "$(date +'%m-%d-%Y %T %z') -- Container for host ${HOST} is online with new image!";
                        EC=0;
                        break;
                    fi
                    echo "Catalog container not online. Waiting...";
                    EC=1;
                    sleep 10;
                    ATTEMPTS=$((ATTEMPTS+1));
                done
                if [[ $EC -ne 0 ]]; then
                    echo "$(date +'%m-%d-%Y %T %z') -- (${HOST}): Container never came online with new image. Still running ${TARGET_IMAGE}!"
                    exit 1;
                fi
            done
        }
        ssh-keyscan $DEPLOY_HOST_B >> ~/.ssh/known_hosts;
        ssh-keyscan $DEPLOY_HOST_C >> ~/.ssh/known_hosts;
        catalogwait;
        apk add curl || apt install curl -y;
        echo "Enabling auto configure temporarily";
        setconfig "false" "true";
        echo "Running Vufind upgrade now against ${URL}";
        curl "${URL}/vufind/Upgrade/GetSourceVersion" --data-raw "sourceversion=${PREV_VUFIND_VERSION}&skip%5B%5D=config" -L -O;
        echo "Upgrade complete with exit code $?";
        echo "Disabling auto configure";
        setconfig "true" "false";

Vufind Populate Environment:
  stage: Post-Deploy
  extends: .stack_template
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/'
  needs:
    - job: Set Stack Name
      artifacts: true
    - job: Vufind Upgrade
  script:
    - ssh-keyscan $DEPLOY_HOST_B >> ~/.ssh/known_hosts;
    - ssh-keyscan $DEPLOY_HOST_C >> ~/.ssh/known_hosts;
    # Determine if records are already loaded
    - |
        STAT_CD=$(ssh deploy@$DEPLOY_HOST_A "docker exec \$(docker ps -q -f name=${STACK_NAME}-catalog_catalog) curl 'http://solr:8983/solr/biblio/select?indent=true&q.op=OR&q=*%3A*&rows=0' --write-out %{http_code} --silent --output /dev/null");
        if [[ "${STAT_CD}" -ne 200 ]]; then
            echo "Failed to get number of records from Solr. Curl returned ${STAT_CD}.";
            exit 1;
        fi;
        NUM_RECS=$(ssh deploy@$DEPLOY_HOST_A "docker exec \$(docker ps -q -f name=${STACK_NAME}-catalog_catalog) curl -s 'http://solr:8983/solr/biblio/select?indent=true&q.op=OR&q=*%3A*&rows=0' | jq '.response.numFound'");
        if [[ "${NUM_RECS}" -eq "0" ]]; then
            # Load some records
            echo "Running harvest-and-import.sh now";
            ssh deploy@$DEPLOY_HOST_A "docker exec \$(docker ps -q -f name=${STACK_NAME}-catalog_catalog) /harvest-and-import.sh -c -l 1 -b -r >/dev/null 2>&1";
            echo "Import completed with exit code $?";
            # Rebuild alphabetic browse databases
            echo "Running Alphabetic browse database build";
            ssh deploy@$DEPLOY_HOST_A "docker exec \$(docker ps -q -f name=${STACK_NAME}-solr_cron) /alpha-browse.sh -v -p /mnt/shared/alpha-browse/${STACK_NAME}";
            ssh deploy@$DEPLOY_HOST_B "docker exec \$(docker ps -q -f name=${STACK_NAME}-solr_cron) /alpha-browse.sh -v -p /mnt/shared/alpha-browse/${STACK_NAME}";
            ssh deploy@$DEPLOY_HOST_C "docker exec \$(docker ps -q -f name=${STACK_NAME}-solr_cron) /alpha-browse.sh -v -p /mnt/shared/alpha-browse/${STACK_NAME}";
            echo "Completed alphabetic browse database build";
        else
            echo "${NUM_RECS} loaded records already exist. Doing nothing.";
        fi;

Verify Health:
  stage: Post-Deploy
  extends: .stack_template
  needs:
    - job: Set Stack Name
      artifacts: true
    - job: Vufind Upgrade
  script:
    - HOSTS="$DEPLOY_HOST_A $DEPLOY_HOST_B $DEPLOY_HOST_C";
    - |
        checkhealth() {
            SERVICE=$1;
            echo "Checking health for ${SERVICE}...";
            for HOST in ${HOSTS}; do
                ATTEMPTS=0;
                while [[ "$ATTEMPTS" -le 10 ]]; do
                    HEALTH=$(ssh deploy@$HOST "docker inspect --format '{{json .State.Health.Status }}' \$(docker ps -q -f name=${STACK_NAME}-${SERVICE}) 2>/dev/null || echo \"No Health\"");
                    if [[ "${HEALTH}" == "\"healthy\"" ]]; then
                        echo "$(date +'%m-%d-%Y %T %z') -- (${HOST}): ${SERVICE} is healthy."
                        EC=0;
                        break;
                    fi
                    EC=1;
                    sleep 10;
                    ATTEMPTS=$((ATTEMPTS+1));
                done
                if [[ $EC -ne 0 ]]; then
                    echo "$(date +'%m-%d-%Y %T %z') -- (${HOST}): ${SERVICE} is not healthy! (actual health: ${HEALTH})";
                    exit 1;
                fi
            done
        }
    - ssh-keyscan $DEPLOY_HOST_B >> ~/.ssh/known_hosts;
    - ssh-keyscan $DEPLOY_HOST_C >> ~/.ssh/known_hosts;
    - checkhealth mariadb_galera;
    - checkhealth catalog_catalog;
    # Give solr more time before attempting since it takes longer to start cluster
    - sleep 10;
    - checkhealth solr_solr;

Remove Environment:
  stage: Cleanup
  extends: .stack_template
  image: $CI_REGISTRY_IMAGE/ansible:latest
  environment:
    name: $CI_COMMIT_BRANCH
    action: stop
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/'
      when: manual
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Vufind
  script:
    # Add .aws credentials
    - cat provision-dns-playbook/variables.yml | envsubst | sponge provision-dns-playbook/variables.yml
    # Replace STACK_NAME in env/prod/main.tf and create host file in provision-dns-playbook
    - cat dns-terraform/env/prod/main.tf | envsubst | sponge dns-terraform/env/prod/main.tf
    # Run playbook
    - ansible-playbook provision-dns-playbook/decommission.yml
    # Remove the alphabetic browse databases
    - ssh deploy@$DEPLOY_HOST_A "docker exec \$(docker ps -q -f name=$STACK_NAME-solr_cron) rm -rf /mnt/shared/alpha-browse/${STACK_NAME}"
    # Cleanup volumes/networks/images/containers
    - >
      ssh deploy@$DEPLOY_HOST_A
      "docker stack rm $STACK_NAME-solr;
      docker stack rm $STACK_NAME-mariadb;
      docker stack rm $STACK_NAME-catalog;
      docker stack rm $STACK_NAME-internal;
      rm -rf $COMPOSE_PATH;
      sleep 15;
      docker system prune -a -f
      docker volume ls --filter name=$STACK_NAME --format '{{.Name}}' | xargs -n 1 docker volume rm"
    - ssh-keyscan $DEPLOY_HOST_B >> ~/.ssh/known_hosts
    - ssh-keyscan $DEPLOY_HOST_C >> ~/.ssh/known_hosts
    - ssh deploy@$DEPLOY_HOST_B "docker system prune -a -f; docker volume ls --filter name=$STACK_NAME --format '{{.Name}}' | xargs -n 1 docker volume rm"
    - ssh deploy@$DEPLOY_HOST_C "docker system prune -a -f; docker volume ls --filter name=$STACK_NAME --format '{{.Name}}' | xargs -n 1 docker volume rm"

############# Templates ###############

.stack_template:
  tags:
    - msul-shared
  extends: .setup_ssh
  retry: 2
  variables:
    ENCODED_PRIVATE_KEY: $DEPLOY_PRIVATE_KEY
    SERVER: $DEPLOY_HOST_A
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_COMMIT_BRANCH =~ /^devel-/ || $CI_COMMIT_BRANCH =~ /^review-/ || $CI_PIPELINE_SOURCE == "schedule"'
  needs:
    - job: Set Stack Name
      artifacts: true
    - Deploy Compose Files

include:
  - project: 'msu-libraries/public/cicd-templates'
    ref: main
    file: 'SSH.gitlab-ci.yml'
  - 'templates/Build.gitlab-ci.yml'
  - 'templates/Scan.gitlab-ci.yml'
  - 'templates/Release.gitlab-ci.yml'
